
# Notes 
#   - Created by Noah [Apr 2025]
#   - Usage notes:
#       - Use `File > Script File...` in IDA Pro to make these functions available in the debugger console.
#   - Also see:
#       - Similar objc scripts here: https://x.com/patch1t/status/1430110029537943552?lang=ar-x-fm
#       - `Reverse Engineering [Apr 2025].md` in our notes repo.

import re
import ctypes
import traceback
import textwrap
from dataclasses import dataclass
import json
import enum
import math
import shlex
import subprocess

# --- MARK: Shared

def mftypes(type_library_name=None, syms=False):
    """
    How to preserve analysis work between different IDBs (IDA Projects)?
        - Meta: [May 2025] I researched this a bit just to get an overview, but I stopped, since this hasn't actually become a pain-point in my workflow as of yet.
        - Technologies in IDA:
            - FLIRT: Maps a library function's assembly bytes to its known name. Stored in .sig files. – This isn't that relevant for Apple development, since the libraries in the dyld_shared_cache aren't stripped afaik.
            - Lumina - Stores all (?) the info you'd create while analyzing a function in IDA – comments, names of stackvars, etc. in a database. But requires running a server which seems annoying. Also doesn't work for typedefs, only function protos (IIRC)
            - Type libraries: Contains maps from typename->typedefs and from symbolname->function-prototype. Stored in .til files. 
                This should be enough to share useful info between our IDBs. 
                However, working with these is a bit weird:
                    Ways to add types and function prototypes from a til into the IDA GUI:
                        - [function prototypes] By renaming a function (N) to the name it has in the type library, IDA automatically loads its prototype from the type library, and then it also shows up under 'Functions'
                        - [types] At `Local Types > Add Type... > Import standard structure` you can browse types from the til. (But not the function prototypes)
                    Ways to inspect contents of a tilib:
                        Problem: Function prototypes from the til that haven't been applied to the current database don't seem to be inspectable in the IDA GUI at all.
                        Solution: You can also the data from a til using IDA's tilib clt, e.g. `tilib -l <path>/<to>/macos14_sdk00_arm64.til`
                        Solution: I managed to iterate the function prototypes using IDAPython by using the ida_typeinf.next_named_type() API with the NTF_SYMM flag, but this is quite slow. tilib is much faster.
                            Note: There are other ways in ida_typeinf to iterate the types of a library, but I couldn't get any of the other ones to show me function protos.
                    Writing types and function-prototypes from the IDB to a tilib
                        Haven't looked into this, yet.
            - C-header files
                - They can contain typedefs and function prototypes just like a tilib and are easier to handle (Why do tilib files even exist?)
                - IDA Pro GUI can create a C header but it only contain typedefs, not function prototypes :/ [May 2025]
                - Idea: perhaps we could create an IDAPython script which exports typedefs and protos (which aren't defined in a type-library) to a C header, and then import that back into IDA using the GUI. Should maybe research if that already exists, since it seems very universally useful.
            - Other files IDA can 'Produce'
                - There's a bunch like IDC, and SIG. I haven't looked into that.
        - Swift (Slightly off-topic)
            Swift symbols contain something like a function prototype when demangled, but it doesn't contain all the information. 'full' function prototype is found in .swiftinterface files in the macOS SDK, but I think IDA doesn't parse those. (I think that because IDA's macOS type-libraries, don't contain any Swift functions IIRC, even though I suspect they are autogenerated from the macOS SDKs)

    Also see:
        - Igor's TOTW   – Type libraries:           https://hex-rays.com/blog/igors-tip-of-the-week-60-type-libraries
        - Synacktiv     – Investigating Lumina:     https://www.synacktiv.com/en/publications/investigating-ida-lumina-feature
        - Hexrays       – FLIRT In-Depth:           https://docs.hex-rays.com/user-guide/signatures/flirt/ida-f.l.i.r.t.-technology-in-depth#goal
        - Lumen         - A private Lumina Server:  https://github.com/naim94a/lumen
        - Claude        – Share info between IDBs:  https://claude.ai/share/8023f147-1699-4b37-a9cb-4de19618bb26
        - Claude        - .swiftinterface:          https://claude.ai/share/763f6f92-32bb-4148-b20c-e9cc035af55d 
    """
    
    assert False, "Use tilib clt to inspect type libraries, it's much faster than this code."
    if (0):
        til = None
        if not type_library_name:   til = ida_typeinf.get_idati() # Get type library of the current IDB (I think we could also just pass nil to first_named_type())
        else:                       til = ida_typeinf.load_til(type_library_name)
        
        result = []
        if syms:
            # Gather all the symbols (in the type library)
            name = ida_typeinf.first_named_type(til, ida_typeinf.NTF_SYMM) # Iterate (mangled) symbols. NTF_SYMU would iterate the unmangled symbols
            while name:
                # Get type string (function signature)
                tuple = ida_typeinf.get_named_type(til, name, ida_typeinf.NTF_SYMM)
                tif = ida_typeinf.tinfo_t(); tif.deserialize(til, tuple[1], tuple[2])
                # Store
                result.append((name, tif.__str__()))
                # Increment
                name = ida_typeinf.next_named_type(til, name, ida_typeinf.NTF_SYMM)
        else:
            # Gather all the named types (in the type library)
            name = ida_typeinf.first_named_type(til, ida_typeinf.NTF_TYPE)
            while name:
                # Get type string
                tuple = ida_typeinf.get_named_type(til, name, ida_typeinf.NTF_TYPE)
                tif = ida_typeinf.tinfo_t(); tif.deserialize(til, tuple[1], tuple[2])
                # Store
                result.append((name, tif.__str__()))
                # Increment
                name = ida_typeinf.next_named_type(til, name, ida_typeinf.NTF_TYPE)
            
        return result
    

def mfdbg_waitfor(process_name):
    
    """
    Wait for a process to launch and then immediately attach IDA's debugger
        Background: [Jun 2 2025] I made this for analyzing the KeyboardSettings process which has to be started by System Settings to run properly. lldb/Xcode has a builtin feature to wait for a process-launch but IDA's debuggers do not (as far as I can tell). Good thing IDAPython exists! 
        Performance: This doesn't attach _immediately_ after process launch, but it attaches somewhere in the dyld-setup-code (IIRC) which is well before the _main function and good enough for our current usecase of [Jun 5 2025] Perhaps some objc +[load] calls would execute before this attaches?
        Alternatives: 
            - We could perhaps edit the assembly to contain an infinite loop at the entry point (and then break that loop after the debugger attaches)
            - lldb and apples branch of gdb had a native 'waitfor' option.
    """
    
    # Compile arglist for pgrep clt
    cmds = shlex.split(f"pgrep -o '{process_name}'")
    
    # Wait for process to launch
    pid = None
    while 1: 
        pid_str = subprocess.run(cmds, stdout=subprocess.PIPE).stdout
        if pid_str != b'':
            pid = int(pid_str)
            break
    
    # Attach debugger to found process
    ret = ida_dbg.attach_process(
        pid, 
        ida_idd.PROCESS_ATTACHED # Not sure what this does / if it's correct [Jun 2025]
    );
    
    # Validate
    assert ret == 0

def mfround_base(x, fn, multiple, base):
    """
    Generalization of round/floor/ceil functions
    Behavior: 
        Imagine an interval [base, base+multiple], and then infinitely copy-paste this interval at base+0*multiple, base+1*multiple, ...
        See which of these intervals x lies in and then snap x to the upper- or lower-bound of that interval. 
            (mffloor snaps to lower-bound, mfceil snaps to upper-bound, mfround snaps to the nearest bound)
    """
    return (fn(float(x-base)/multiple) * multiple) + base
def mfround(x, multiple=1, base=0):         return mfround_base(x, round,       multiple, base)
def mffloor(x, multiple=1, base=0):         return mfround_base(x, math.floor,  multiple, base)
def mfceil(x, multiple=1, base=0):          return mfround_base(x, math.ceil,   multiple, base)

def mfbits(x, len=None, sep=" "):
    """
    Get raw bits of a number
        Python's bin() shows ascii minus `-` instead of raw bits for two's complement'ed ints.
    """
    assert isinstance(x, int)
    result = ""
    finito = 0 if x>=0 else -1
    i = 0
    while 1:
        if      len     and i >= len:       break
        elif    not len and x == finito:    break
        if i and 0==i%8: result += sep
        if x & 1:   result += '1'
        else:       result += '0'
        x >>= 1
        i += 1
    return result[::-1]

def mfcatch(f):
    """
    Turn try/catch into a one-liner
    Example usage:
        mfcatch(lambda: [1,2,3][4])
    """
    result  = None
    error   = None
    try:                    result = f()
    except Exception as e:  error = e
    return (result, error)

def mferrdesc(err, detail=2):
    """
    Get full (hopefully) description of error, 
        Should be useful for mfcall(<..>, debug=True)
            Example: print(mferrdesc(mfcatch(lambda: mfcall('_func_that_derefs_ptr', "void f(int *x);", debug=True)(invalid_ptr))[1]))
        Note: [May 2025] While using this with mfcall(<..>, debug=True) shows a lot of error info, IDC still shows some extra stuff. Not sure if important
            IDC Example: SetAppcallOptions(APPCALL_DEBEV); auto e; try { <some throwing appcall>; } catch (e) { print(e); };
    """
    if detail==1:
        result = ''.join(traceback.TracebackException.from_exception(err).format())
    elif detail==2: # Src: https://stackoverflow.com/a/37135014/10601702 || Not sure this actually provides more detail than detail==1
       tracedesc = "".join(traceback.format_list(traceback.extract_tb(err.__traceback__)))
       argdesc = ""
       for i, arg in enumerate(err.args):
            if i: argdesc += "\n"
            argdesc += str(type(arg)) + "\n"
            if hasattr(arg, '__dict__'):    # [May 2025] This works for Appcall errors with APPCALL_DEBEV set
                desc = json.dumps(arg.__dict__, indent=4)
                desc = re.sub(r"\d+", lambda d: hex(int(d.group(0))), desc) # Convert numbers to hex (When IDA dumps an IDAPython object to the output window, it seems to do the same thing to the output of .__repr__)
                argdesc += desc
            elif isinstance(arg, str):      # [May 2025] This works for Appcall errors with APPCALL_DEBEV *not* set
                argdesc += textwrap.indent(arg, ' '*4)
       result = textwrap.dedent("""
            {a}
                Args:
            {b}
                Trace:
            {c}
        """)[1:-1].format(a=err.__class__, b=textwrap.indent(argdesc, 8*' '), c=textwrap.indent(tracedesc, 8*' '))
    else: assert False
    
    return result

def mfbpt(ea, size):
    # Make a breakpoint
    #   Background: The reason we wanna use this over the IDA GUI for creating breakpoints is that the IDA GUI doesn't let us create bpts > 8 bytes. [May 19 2025] (IDA Version 9.1.250226 macOS arm64 (64-bit address size))
    #   Discussion: Only creates write-access breakpoints atm since that's all we're interested for now [May 19 2025]
    
    # Helper function
    def _add_bpt(ea, size):
        bpt = ida_dbg.bpt_t()
        bpt.set_abs_bpt(ea)
        bpt.size = size
        bpt.type = BPT_WRITE
        bpt.flags = BPT_BRK | BPT_TRACE | BPT_UPDMEM | BPT_ENABLED
        add_bpt(bpt)

    # Make several bpts of size <= 8
    #   (When we make a bpt > 8 bytes, the API fails [May 19 2025])
    ea_hi = ea+size
    while 1:
        remaining = ea_hi - ea
        if remaining <= 8:
            _add_bpt(ea, remaining)
            break
        else:
            _add_bpt(ea, 8)
            ea += 8

def mfbpt_del(ea, size):
    # Delete all breakpoints in the address range
    for ea in range(ea, ea+size):
        del_bpt(ea)
        
def mfclear():
    """
    Clear the text in IDAs output View
    """
    result = ida_kernwin.process_ui_action("msglist:Clear")
    return None

def mfcstr(addr):
    """
    Read a NULL-terminated utf-8 C-String from the address and return it as a Python string.
    """
    if 1:
        str_len = idaapi.get_max_strlit_length(addr, STRTYPE_C, ida_bytes.ALOPT_IGNCLT) # [May 2025] Without ALOPT_IGNCLT, special characters like `▿` in Swift's dump() output seem to cut the string short. We really just wanna read until the NULL-terminator... However that might run forever if we erroneously try to read some memory region that doesn't contain a string.
        str_bin = idaapi.get_strlit_contents(addr, str_len, STRTYPE_C)
    if 0:
        str_bin = bytearray()
        while b := ida_bytes.get_byte(addr): # Read bytes until NULL terminator
            str_bin.append(b)
            addr += 1
    if 0:
        pass
        # I just saw Appcall.cstr() exists! Should've probably used that.
    
    str_py = str_bin.decode('utf-8') if str_bin else "<mfnull>"
    return str_py
    
def mfmodat(i) -> ida_idd.modinfo_t:
    """
    Get module at index i
    """
    result = None
    for j, mod in enumerate(idc._get_modules()):
        if j == i: result = mod; break
    return result if result else None

def mfmodsnamed(s) -> ida_idd.modinfo_t:
    """
    Get all modules whose path contains s
    """
    result = []
    for i, modinfo in enumerate(idc._get_modules()):
        if s in modinfo.name:
            result.append(modinfo)
    return result

def mfmodaddrs(m: ida_idd.modinfo_t) -> (idaapi.ea_t, idaapi.ea_t):
    """
    Get the range of addresses for a module
      Caution: [Apr 2025] For modules in the dyld_cache, it looks like their address ranges are disjointed, and this function's result won't cover all the addresses. See where we wrote about 'Disjointed modules'
    """
    if isinstance(m, list): return [(x.base, x.base+x.size-1) for x in m]
    else:                   return (m.base, m.base+m.size-1)

class _mffrm(object):
    """
    [May 2025] Convenience for accessing stack variables in the stack-frame of the currently executing function.
          Example: If you see `[SP,#0x5C0+var_370]` in the disassembly, you can use `cpu.SP+0x5C0+mffrm.var_370` from the console to read the var_370 stack-variable
          Tip: Select a function and press ctrl-K to inspect the stack struct in IDA.
          Caution: [May 2025] IDA tries to normalize all stack vars to be relative to the FP (x29) but I saw it fail. (I think it can get confused if the SP moves during function execution.)
          Also see:
              - IDA's example project "list_frame_info.py"
              - ida_frame.py functions (we aren't using those yet as of [May 4 2025])
        Update: [May 15 2025]
            In IDC, this is all built in! You can just type `SP+0x5C0+var_370` (In IDAPython we'd use `cpu.SP+0x5C0+mffrm.var_370`)
    """
    
    def _dict(self, func_addr = None):
        func_addr = func_addr or cpu.PC
        func = idaapi.get_func(func_addr)
        result = dict()
        assert (func.flags & FUNC_FRAME) and func.fpd==0, f"Unexpected function attributes. Result will probably be incorrect. (See .frsize docs.)"
        frame_tif = func.frame_object
        for x in frame_tif.iter_struct():
            anchor  = func.frsize
            offs    = x.offset/8; assert offs.is_integer(); offs = int(offs)
            result[x.name] = offs-anchor
        return result

    def __getattr__(self, attr):    return self._dict()[attr]
    def __repr__(self):             return "\n".join([ f"    {k}: {v:016X}" for (k, v) in self._dict().items()]) # Ez printing in the IDA console

mffrm = _mffrm()

def mfdlsym(name, modpath=None, print_errors=True):
    """
    Find symbol address by name
    """
    
    # Try different approaches
    #   Observations: [May 2025]
    #   - We try 3 approaches: dlsym, get_debug_name_ea, and get_name_ea_simple
    #       get_name_ea_simple
    #           Pro: Saw it find symbols in module 0 that the others don't (_$s16KeyboardSettings27KeyboardShortcutSectionViewVMn inside KeyboardSettings.appex)
    #           Contra: Saw it not find symbols in the other modules. Saw it find symbols in the UNDEF section (imports – those aren't useful here.)
    #       dlsym and get_debug_name_ea
    #           Difference: Don't remember
    #  Random observations:
    #       Weird problem I ran into: [Apr 2025] When we used get_name_ea_simple() to find _objc_msgSend, it looked like the *same* address inside libobjc.A.dylib image showed up as _objc_msgSend in KeyboardSettings.i64 but as _objc_msgSend_noarg_0 in swift-ida-playground-apr-2025.i64. Confusing.
    
    symbol_ea = None
    debug_retrieval_method = None
    if 1:               # Option 1 - dlsym
        name1 = name[1:] if (name[0] == '_') else name # Remove underscore prefix (Not exactly sure how the rules for this work in dlsym. Some Swift symbols don't have underscore prefix, how does that work?)
        
        RTLD_LAZY	    = 0x1
        RTLD_NOW	    = 0x2
        RTLD_LOCAL	    = 0x4
        RTLD_GLOBAL	    = 0x8
        RTLD_NOLOAD     = 0x10
        RTLD_NODELETE   = 0x80
        RTLD_FIRST      = 0x100
        RTLD_NEXT	    = -1
        RTLD_DEFAULT	= -2
        RTLD_SELF	    = -3
        RTLD_MAIN_ONLY	= -5
        
        handle = None
        if not modpath:
            handle = RTLD_DEFAULT
        else:
            dlopen = Appcall.proto("_dlopen", "void* dlopen(const char* path, int mode);")
            handle = dlopen(modpath, RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE)
        
        dlsym = Appcall.proto("_dlsym", "void* dlsym(void* handle, const char* symbol);")
        symbol_ea = dlsym(RTLD_DEFAULT, name1)
        if symbol_ea < 0:
            symbol_ea = int(mfbits(symbol_ea, len=64, sep=""), 2)                           # Reinterpret the raw bytes as a positive int || [May 13 2025] In KeyboardSettings.i64, I saw this be necessary for `dlsym(dlopen("/usr/lib/libobjc.A.dylib", 0), "sel_getUid")`
        if symbol_ea not in range(ida_ida.inf_get_min_ea(), ida_ida.inf_get_max_ea()+1):    # Check if ea is in range || [May 13 2025] In KeyboardSettings.i64 I saw dlsym return seemingly random stuff. Also saw it return valid address with weird stuff in the high bits. E.g. for objc_msgSend it returned 0x140e000184cfd800, where 0x184cfd800 was the actual address. Perhaps something about pointer authentication? Could only observe this in arme apps not arm ones. (Only tested one arme and one arm app.)
            if 0: print(f"Warn: dlsym result out of range: 0x{symbol_ea:x}")
            symbol_ea = None
        debug_retrieval_method = 'dlsym'
        
    if not symbol_ea:   # Option 2 – get_debug_name_ea
        symbol_ea = idaapi.get_debug_name_ea(name)
        debug_retrieval_method = 'get_debug_name_ea'
    
    if not symbol_ea:   # Option 3 – get_name_ea_simple
        symbol_ea = get_name_ea_simple(name)
        debug_retrieval_method = 'get_name_ea_simple'
    
    if 0: print(f"Found symbol using method '{debug_retrieval_method}'")
    
    # Validate result
    segname = idaapi.get_segm_name(idaapi.getseg(symbol_ea))
    if segname == "UNDEF":
        if print_errors: print(f"Error: Found symbol '{name}' at 0x{symbol_ea:02x} but as an import (probably not useful for debugging)"); # I've only ever seen this happend for get_name_ea_simple()
        symbol_ea = None
    elif symbol_ea == BADADDR:
        symbol_ea = None
    if not symbol_ea:
        if print_errors: print(f"Error: couldn't find function for name: {name}. (You might have to click 'analyze module' in IDA on the module where the function is defined (?)")
    
    # Return
    return symbol_ea

def mfsymgrep(search_pattern, demang=False, addrs:(idaapi.ea_t, idaapi.ea_t)=None):

    """
    Powerful utility for searching all symbols (hopefully) via a regex pattern.
      Set demang=True to apply the search pattern to the *demangled* version of the symbol. (And also return the demangled version)
      Set addrs=(lower, upper) to limit the range of searched addresses
    Output format:
      List of lists l with
          l[0] -> symbol address
          l[1] -> symbol name
          l[2] -> demangled symbol name (Only present if demang=True)
    Examples:
      - Print (mangled) symbols appearing in module 0, whose demangled name contains "type metadata"
          print(*[x[1] for x in mfsymgrep(".*type metadata.*", demang=True, addrs=mfmodaddrs(mfmodat(0)))], sep='\n')
    Notes:
      - `debug names` vs `names`:
              - IDA's `get_debug_name_ea()` functions seem to search all the symbols in the debugee's memory space, while `get_name_ea()` seems to search only the first module, and not the loaded libraries/Frameworks (Perhaps it searches names in IDA's name's database? I think that amounts to the same thing here?)
    Also see:
      - mac-mouse-fix > PrivateFunctions.m > "Searching symbol table alternatives"
    Optimization: [Mar 2025]
      - This is slow. lldb's `image lookup -rn` is much faster.
      - However it shouldn't be a problem for my workflow (You can just save result of this and then filter further)
      - Here are some old ideas for optimizing this:
          - Do batching – move as much code as possible outside the python for-loop:
              I tried concatting the names into a long string and run a regex on that – but I'm not sure that made it faster.
          - Do parellelization
          - Use some external C library. 'CoreSymbolication' sounds interesting: https://github.com/rodionovd/liblorgnette?tab=readme-ov-file
          - Use some python library. macholib is written in python so might also be slow? https://github.com/ronaldoussoren/macholib/blob/master/macholib/macho_dump.py
              - I tried the `import lldb` python lib at `python-and-c-playground-apr-2025 > symgrep` but just attaching lldb seemed to parse all the symbols and take much longer.
          - Use command-line-tool. I could print all symbols using `objdump --syms...` but that won't work for a running process, only for an on-disk object-file afaik.
          - Write own dylib that parses/searches the mach-o symbol table using a regex. We could use the dynamic linker we wrote inside 'PrivateFunctions.m' as basis.
          - Write a C++ plugin for IDA that we can call from the python script – just using the IDA apis and regexing from C++ instead of python might bring signification speedup.
    Observation - Disjointed modules:
      Another interesting thing I found is that there seem to be several, disjointed sections of the address space that belong to the 'libswiftCore.dylib' module.
      The '_$sSSN' symbol is defined at a wayyy later address than the libswiftCore.dylib header.
      When you ask IDA for the range of addresses of libswiftCore.dylib, the address of `_$sSSN ` outside of that.
      I vaguly remember reading about some weird dyld_cache optimizations that match what we're observing here, but I might be misremembering.
    """
    
    # Parse addrs arg
    if not addrs: addrs = [None, None]
    addrs = list(addrs)
    if not addrs[0]: addrs[0] = ida_ida.inf_get_min_ea()
    if not addrs[1]: addrs[1] = ida_ida.inf_get_max_ea()
    
    # Search debug names
    if 1:
        # Approach 2
        #   - Based on IDA's show_debug_names.py example
        #   - Using get_debug_names() seems noticably faster than get_debug_name() (which we used in Approach 1)
        rgx = re.compile(search_pattern, flags=0)
        result = []
        dn = set(ida_name.get_debug_names(addrs[0], addrs[1]).items())
        dn |= set([(ea, name) for (ea, name) in Names() if ea in range(addrs[0], addrs[1])]) # Also search non-debug names – deduplicate using set
        print(f"namecount prefilter: {len(dn)}")
        for symea, symname in dn:
            if symname is None: continue # [May 13 2025] Just observed this. Not sure why.
            symdemang = mfsdemang(symname) if demang else None
            skip = demang and not symdemang
            searchstr = symdemang or symname
            if not skip:
                if rgx.fullmatch(searchstr): # [Apr 2025] Tried rgx.search but it was much slower.
                    x = [symea, symname]
                    if symdemang: x.append(symdemang)
                    result.append(x)
        print(f"namecount final: {len(result)}")
        return result
    
    if 0:
        # Approach 1
        rgx = re.compile(search_pattern, flags=0)
        result = []
        ea = 0 # Not sure what to use as base address
        while 1:
            symname = idaapi.get_debug_name(ea, idaapi.DEBNAME_LOWER)
            symea = idaapi.get_debug_name_ea(symname) # Maybe use get_debug_names() if this is slow
            symdemang = None
            if demang:
                symdemang = mfsdemang(symname)
            if symea == BADADDR: break
            skip = demang and not symdemang
            if not skip:
                if rgx.fullmatch(symdemang or symname): # [Apr 2025] Tried rgx.search but it was much slower.
                    x = [symea, symname]
                    if symdemang: x.append(symdemang)
                    result.append(x)
            ea = symea+1
        return result

class _mfmem(object):
    """
    Convenience for reading/writing memory
      Examples: [May 2025]
          mfmem[cpu.X0, 'void *;']                              -> Dereference the pointer stored in the X0 register
          mfmem[cpu.X29-0x48, 'char *;']                        -> Read the utf-8 C-String pointed to by the FP-0x48 stack variable
          mfmem[0x123, 'char[8];']                              -> Read the first 8 bytes of the (not-null-terminated) utf-8 string at 0x123
          mfmem[0x891, 'uint8_t[12];']                          -> Read an array of 12 bytes starting at 0x891
          mfmem[0x891, 'float;']                                -> Read a 32-bit float at 0x891
          mfmem[0x891, 'double[3];']                            -> Read 3 64-bit floats at 0x891
          mfmem[0x891, 'struct { uint32_t i; double f; }']      -> Read a struct containing an uint32_t and a double at 0x891
          mfmem[0x891, 'float;'] = 1.2                          -> Write a float at 0x891
          mfmem[0x891, 'double[3]] = [1.2, 2.3, 3.4]            -> Write an array of 3 doubles starting at 0x891
          mfmem[0x891,                                          -> Write a struct containing 2 uint64_t starting at 0x891
              'struct { uint64_t a; uint64_t b; };'] =
                  { 'a':0xfff, 'b': 0xfafafa }
          bytes(mfmem[0x891, 'uint8_t[16];'])                       -> Load bytes from 0x891 to (0x891+15) into a bstring
          mfmem[bytes_object, 'Swift::String;']                     -> Deserialize a Swift.String from a bytes object.
          bytes_object = mfmem.tobytes(sw_str, 'Swift::String;')    -> Serialize a Swift.String into a bytes object.  
      Implementation notes:
          [May 2025] We're using the internal methods used by the Appcall.typedobj().store() and Appcall.typedobj().retrieve() APIs. That is so we can pass-in custom flags. (Which we don't use so far)
    """
    
    @staticmethod
    def _tifarrcount(tif: ida_typeinf.tinfo_t): # Get count of a c array
        assert tif.is_array()
        return int(tif.get_size()/tif.get_ptrarr_objsize())
        
    def __getitem__(self, subscript):
        ea, tp, *rest = subscript
        pt_flags  = rest[0] if len(rest) > 0 else None
        pio_flags = rest[1] if len(rest) > 1 else 0
        tif = ida_idd.Appcall__._Appcall____typedecl_or_tinfo(tp, pt_flags)
        if 1:
            # Special case – uint8_t[N]
            # [May 2025] This makes uint8_t[N] behave like uint16_t[N] or uint32_t[N]. Otherwise uint8_t[N] will behave like char[N] (IDA will try to parse it as a string.)
            if (tif.is_array() and
                tif.get_ptrarr_objsize() == 1 and # Redundant with .is_char() I think
                tif.get_ptrarr_object().is_integral() and
                not tif.get_ptrarr_object().is_char()):
                return list(ea) if isinstance(ea, bytes) else list(ida_bytes.get_bytes(ea, tif.get_size()))
            # Special case – char *
            # [Mar 2025] Interpret char * as NULL-terminated string
            if (tif.is_ptr() and
                tif.get_ptrarr_object().is_char()):
                return mfcstr(ea)
        ok, obj = ida_idd.Appcall_callable__(None, tif).retrieve(ea, pio_flags)
        assert ok
        if 1: # Convert ida_idaapi.object_t to native-python types for easier handling. (For __setitem__(), the APIs we're using seem to do the same conversions automatically. [May 2025])
            if tif.is_array() and hasattr(obj, '0'): obj = [obj[f'{i}'] for i in range(_mfmem._tifarrcount(tif))] # Convert array-object to list
            if hasattr(obj, '__dict__'): obj = { k: v for (k, v) in obj.__dict__.items() if k != '__at__' } # Convert struct-object to dict
        return obj
        
    def __setitem__(self, subscript, obj):
        ea, tp, *rest = subscript
        pt_flags  = rest[0] if len(rest) > 0 else None
        pio_flags = rest[1] if len(rest) > 1 else 0
        tif = ida_idd.Appcall__._Appcall____typedecl_or_tinfo(tp, pt_flags)
        if tif.is_array(): assert _mfmem._tifarrcount(tif) > 0, "Arrays with unspecified size (int[];) don't work as expected. Specify size (int[3];) or use a ptr (int*;) instead."
        ret = ida_idd.Appcall_callable__(None, tif).store(obj, dest_ea=ea, base_ea=0, flags=pio_flags)
        return ret # Return is ignored when using subscript-syntax
        
    def tobytes(self, obj, tp, pt_flags=None, pio_flags=0):
        # Explanation: Calling __setitem__ with an ea of None makes it return a byte-string. But if you use the subscript-syntax for that `mfmem[None,t]=x`, it swallows the return value.
        #   so we created the .tobytes() function.
        (ok, ret) = self.__setitem__((None, tp, pt_flags, pio_flags), obj) 
        assert ok, f"Failed with error: {ret}"
        return ret
            
        
mfmem = _mfmem()

def mfderef(p, n=1): # shorthand for dereferencing a pointer
    result = p
    for _ in range(n):
        result = mfmem[result, 'void*;'];
    return result

# --- MARK: objc

def mfclssize(cls):
    """
    Get size of an objc class
      Should also work on all Swift reference types since they all support the objc runtime to some extent (Wrote more about this elsewhere – grep 'reference types'). Also see mfssize()
    Example usage:
      mfclssize(mfcls("NSBundle"))
    Discussion:
      Some classes like NSString will report an instance size of 0x8 (just the isa pointer) but they will dynamically allocate additional memory. Use _malloc_size() in that case.
    """
    return Appcall.proto(mfdlsym('_class_getInstanceSize'), "size_t __cdecl class_getInstanceSize(Class cls);")(cls)

def mfasize(p):
    """
    Get (a)llocated size at an address
    Example usage:
      print(hex(mfasize(mfstr(0x1E*"X"))), hex(mfasize(mfstr(0x1F*"X")))) -> This example shows the allocation-size-patterns of NSString
    """
    return Appcall.proto(mfdlsym("_malloc_size"), "size_t __cdecl malloc_size(const void *ptr);")(p)

def mfisobj(p, verbose=False):
    """
    Check if a ptr points to an objc object or a Swift reference type.
        (All Swift reference types have the same basic memory layout as objc objects and can interact with the objc runtime. See https://github.com/swiftlang/swift/blob/main/docs/DynamicCasting.md#anyobject)
    This implementation is a heuristic. It might fail in some cases.
    Alternative implementations:
        - https://blog.timac.org/2016/1124-testing-if-an-arbitrary-pointer-is-a-valid-objective-c-object/IsObjcObject.c
    """
    try:
        getcls      = Appcall.proto(mfdlsym("_object_getClass"), "Class f(id);")
        ismetacls   = Appcall.proto(mfdlsym("_class_isMetaClass"), "BOOL f(Class cls);")
        metacls     = getcls(getcls(p));
        max_iters   = 10 # I thought a metaclass must always be its own metaclass but I've seen a deeper 'metaclass-hierarchy' for some Swift type (I think it was a keypath). We go up to the 10th meta-meta-meta-...-class before giving up. [May 21 2025]
        i           = 0
        while 1:
            if not ismetacls(metacls):  return False
            if i >= max_iters:          assert False; return False
            nextcls = getcls(metacls);
            if metacls == nextcls:      return True
            metacls = nextcls
            i += 1
    except Exception as e:
        if verbose: print(f"Failed with exception {e}")
        return False

def mfcls(cls_name):
    """
    Get an objc class object by name
    """
    objc_getClass = Appcall.proto(mfdlsym("_objc_getClass"), "void *f(char *);")
    result = objc_getClass(cls_name)
    return result

def mfsend(
    obj_addr,
    method_name,
    *args,
    proto="void *f(void *self, void *op);"
):
    """
    Invoke a method on an objc object. 
        Example: cls = mfsend(cpu.X0, "class")
    Caution: 
        - You'll have to override proto if the method takes any args, or returns something that is not pointer-sized. 
    """
    
    sel_getUid = Appcall.proto(mfdlsym("_sel_getUid"), "void *f(char *name);")
    objc_msgSend = Appcall.proto(mfdlsym("_objc_msgSend"), proto)
    
    selector = sel_getUid(method_name)
    result = objc_msgSend(obj_addr, selector, *args)
    
    return result

def mffmt(fmt, *args):
    """
    Call +[NSString stringWithFormat:]
        Example: mfdesc(mffmt("What %s %s. float: %f. object: '%@'", "is", "love", 1.23, mfstr("This is an NSString")))
    (Not sure this is useful for anything but it's cool)
    """
    result = mfsend(mfcls("NSString"), "stringWithFormat:", mfstr(fmt), *args, proto="void *f(void *self, void *op, void *fmt, ...);")
    return result

def mfstr(str):
    """
    Convert a python string to an NSString
    """
    result = mfsend(mfcls("NSString"), "stringWithUTF8String:", str, proto="void *f(void *self, void *op, char *str);")
    return result

def mfdesc(obj_addr):
    """
    Get the result of calling -[description] on an objc-object 
        as a native python string
    Call this to print an objc object (and some (all?) Swift-reference-types) to the IDA debugger console.
    """
    desc = mfsend(obj_addr, "description")
    desc_c = mfsend(desc, "UTF8String")
    desc_py = mfcstr(desc_c)
    return desc_py

# --- MARK: Swift
#   Terminology:
#       mfs -> mf (s)wift
#   Also see: 
#       - https://docs.hex-rays.com/user-guide/debugger/debugger-tutorials/appcall_primer#functions-that-accept-or-return-structures-1
#           - Swift uses many structs instead of objects
#       - The `Reverse Engineering [Apr 2025].md` note in our notes repo.

def mfssize(typ):
    """
    Get size of a swift type
    Example usage:
      - mfssize(mfstype(mfsmang("Swift.Bool")))
      - mfssize(mfstype(mfsmang("Swift.Set<Swift.String>")))
    Also see: mfasize, mfclssize
    """
    return Appcall.proto(mfdlsym('_$ss12MemoryLayoutO4sizeSivgZ'), "void *f(void*);")(typ)

def mfsstr(s):
    """
    Converts a python string to a Swift.String by calling Swift.String.init(cString:) 
    The return value is an ida_idaapi.object_t representing a Swift::String struct (It can be passed to Appcall functions expecting a `Swift::String` struct) (Use .__dict__ to inspect the struct-members)
    """
    if (0):
        # Option 1
        #   [May 20 2025] Currently seeing this fail with a SIGSEGV. Not sure why. Using unconditionallyBridge works. Update: [May 21 2025] I think this might've been cause we were using Appcall's name resolution instead of mfdlsym. That has caused these types of issues before IIRC.
        f = Appcall.proto(mfdlsym("_$sSS7cStringSSSPys5UInt8VG_tcfC"), "Swift::String f(char *);")
        result = f(s)
    else:
        # Option 2
        ns = mfstr(s)
        f = Appcall.proto(mfdlsym("_$sSS10FoundationE36_unconditionallyBridgeFromObjectiveCySSSo8NSStringCSgFZ"), "Swift::String f(NSString *);")
        result = f(ns)
    return result

def mfsstr_tons(swift_string):
    """
    This converts a Swift string to an NSString by calling Swift.String._bridgeToObjectiveC()
    """
    result = Appcall.proto(mfdlsym("_$sSS10FoundationE19_bridgeToObjectiveCSo8NSStringCyF"), "void *__swiftcall f(Swift::String);")(swift_string)
    return result

def mfsstr_tobytes(swift_string):   return mfmem.tobytes(swift_string, "Swift::String;") # Packs a python object representing a swift string to bytes (Which can be passed to mfsdesc())
def mfsstr_frombytes(bytess):        return mfmem[bytess, "Swift::String;"]

def mfsdemang(x, short=False, return_mang=True):
    """
    Should work just like `xcrun swift-demangle` clt.
       Alternative: Could use Appcall.proto(mfdlsym("_swift_demangle")) instead of idc.demangle_name (But they seem to work the same [May 2025])
    Examples: 
        mfsdemang(idaapi.get_func(here()).name)         -> I'm using this rn cause the stack trace in IDA is showing wrong function names [May 2025]
    """
    result = idc.demangle_name(x, get_inf_attr(INF_LONG_DN if not short else INF_SHORT_DN))
    return (result or (x if return_mang else "")) # [May 2025] Return empty-string cause otherwise I sometimes got errors using this in list-comprehension

def mfstype(typ: str) -> idaapi.ea_t:
    """
    Return a type metadata pointer given a mangled Swift type name
    """
    
    # Strip mangling prefix (`_$s`)
    if match := re.fullmatch(r'(_?\$?s).*', typ):
        typ = typ[match.end(1):]
    
    # Try different options for obtaining a reference to the type metadata
    #   Options: [May 2025]:
    #       Option 1 – ...N symbol:                            (...N  demangles to `type metadata for ...`)
    #       Option 2 – ...MD symbol:                           (...MD demangles to `demangling cache variable for type metadata for ...`)
    #       Option 3 - getTypeByMangledNameUntrusted()
    #   Discussion:
    #       - (On Option 1 and 2) I've seen the ...N and ...MD symbols inside the disassembly of the swift-ida-playground-apr-2025 test project where we called String(reflecting:) on various different things
    #       - (On Option 3) I've seen swift_getTypeByMangledName() in the Swift.Mirror source code when the mirror gets the type metadata for its children.
    #           swift_stdlib_getTypeByMangledNameUntrusted is an easy-to-use wrapper. However the Mirror is passing some extra information which we can't pass to the wrapper – I'm not sure what difference that makes.
    #       - When to use each option?
    #           - Not sure, so we just try all of them.
    #           - In my (limited) testing, swift_stdlib_getTypeByMangledNameUntrusted works everywhere where an MD symbol exists, but not where an N symbol exists (e.g. _$sSSN). (Might have to do with the missing context args for the underlying swift_getTypeByMangledName()? – I think swift_getTypeByMangledName() has to work for everything somehow, since Mirror uses it and that works for everything.)
    #           - ...MD symbols (Option 2) have to be used with ___swift_instantiateConcreteTypeFromMangledName – Perhaps manually 'instantiating' the type at least once is also necessary, when using `_swift_stdlib_getTypeByMangledNameUntrusted`? (Option 3).
    result = None
    if 1:
        result = mfdlsym(f"_$s{typ}N", print_errors=False)
    if not result:
        c = mfdlsym(f"_$s{typ}MD", print_errors=False)
        if c:
            assert idaapi.get_segm_name(idaapi.getseg(c)).endswith("__data")
            f = Appcall.proto(mfdlsym("___swift_instantiateConcreteTypeFromMangledName"), "void * f(uint64_t);")
            result = f(c)
    if not result:
        f = Appcall.proto(mfdlsym("_swift_stdlib_getTypeByMangledNameUntrusted"), "void *f(char *, size_t);")
        result = f(typ, len(typ))
    
    assert result
    return result

def mfsdesc(buffer, typ, detail=1):
    """
    Return python string containing result of calling Swift.String(describing:) (et al) on a value.
        This should let us runtime-introspect any Swift type!
    
    Input values:
        - `buffer` can be
            - a pointer to                  the struct-instance to describe
            - a bytes() object containing   the struct-instance to describe
        - `typ` can be 
            - a pointer to          the type metadata for   the instance to describe
            - the mangled name of   the type of             the instance to describe   (This function will then automatically use mfstype() to try and get the pointer to the type metadata)
        - `detail` can be 
            - 1,2, ... to use different Swift functions for describing the value
    Examples:
        1. mfsdesc(0x16FDFEC10, 0x20962c500)                                                    -> Print, given a ptr to a Swift struct and ptr to its metadata
        2. mfsdesc(bytes((ctypes.c_uint64*2)(cpu.X0, cpu.X1)), '_$sSS')                         -> Print, given a Swift struct in registers X0 and X1, and its mangled type name.
        3. mfsdesc(mfmem.tobytes([cpu.X0, cpu.X1], "uint64_t[2];"), '_$sSS')                    -> Same thing as above but using mfmem instead of ctypes.
        4. print(mfsdesc(cpu.X0, mfsmang("[Swift.String:Any]")))                                -> Print, given a ptr to a Swift struct in register X0 and its _non_mangled type name.
        5. mfsdesc(mfmem[cpu.X29-0x48, 'void*;'], '_$sABCDE')                                   -> Print, given a ptr to a Swift struct in stack-variable FP-0x48 and its mangled type name     ([May 2025] I had to do this after a Swift returned through X8 (See Swift's CallingConventionSummary.rst))
        6. mfsdesc(mfsstr_tobytes(mfsstr("What is the meaning of loife")), "_$sSS", detail=2)   -> Print with a specific detail-level
        7. mfsdesc(cpu.SP+0x720+mffrm.var_keypath_array, mfsmang("[Swift.AnyKeyPath]"))         -> Print an array of keypaths from the stack. (This should work for all KeyPath types since they are all subclasses of Swift.AnyKeyPath)
        8. mfsdesc(mfmem.tobytes(cpu.X0, "void *;"), mfsmang("Swift.AnyKeyPath"))               -> Print a keypath that has just been returned to X0 by _swift_getKeyPath
    
    Note:
        - (At least for some) Swift reference types, you can also send them an objc `description` message (mfdesc()) (This works for swift keypaths as of [May 2025] even though they don't have an @objc annotation in the OSS Swift code)

    Tips:
        - How to find mangled type names:
            - mfsymgrep() should be helpful.
    """
    
    # Convert arg `typ` to address
    match typ:
        case int():     pass
        case str():     typ = mfstype(typ)
        case _:         assert False
    
    # Validate input buffer
    #   Discussion: [May 2025] We used to malloc here if the user passed bytes instead of an address, but Appcall can handle that all automatically.
    if isinstance(buffer, (__builtins__.int, __builtins__.bytes)):      pass
    else:                                                               assert False
    
    if detail==1:
        # Retain
        if mfisobj(mfderef(buffer)): mfsend(mfderef(buffer), "retain", proto="id f(void*, void*);") # String(describing:) decrements the retain count for some reason [May 2025] so we need to balance that to prevent the instance from being deallocated.
        # Call String(describing:)
        f = Appcall.proto(mfdlsym("_$sSS10describingSSx_tclufC"), "Swift::String __swiftcall f(void *buffer, void *T);") # When I don't use mfdlsym() here I get really confusing behavior, and this prints `Swift._AnyKeyPath` instead of the keypath's description [May 20 2025]
        str_sw = f(buffer, typ)
    elif detail==2:
        # Retain
        if mfisobj(mfderef(buffer)): mfsend(mfderef(buffer), "retain", proto="id f(void*, void*);")
        # Call String(reflecting:)
        f = Appcall.proto(mfdlsym("_$sSS10reflectingSSx_tclufC"), "Swift::String __swiftcall f(void *buffer, void *T);")
        str_sw = f(buffer, typ)
    elif detail==3:
        # Call dump()
        #   Discussion:
        #       - [May 2025] For the 'App' struct of my fresh SwiftUI project, even dump() prints nothing interesting. To go deeper we'd probably have to analyze metadata directly (like the Echo lib (https://github.com/Azoy/Echo)) ... But that seems not worth it.
        #       - [May 2025] We previously used to malloc a buffer for the result string but it caused random failures like 2/10 times. Now we have Appcall handle everything. Update: Still fails randomly (Update2: I think the problem was about not using mfdlsym [Jun 5 2025])
        #   Also see: Dump.swift in Swift OSS

        str_sw = mfsstr("") 
        return_buf_size = mfceil(mfssize(typ), multiple=16) # Swift assembly I looked at seems to round the buffer size up to a multiple of 16. [May 2025]
        return_buf = Appcall.proto(mfdlsym("_malloc"), "void *malloc(size_t __size);")(return_buf_size) # I tried Appcall.buffer() instead of malloc, but couldn't get it to work. Does it only work for UTF-8 str buffers? [May 2025]
        
        f = Appcall.proto(
            mfdlsym("_$ss4dump_2to4name6indent8maxDepth0E5Itemsxx_q_zSSSgS3its16TextOutputStreamR_r0_lF"),
            """
                __int64 __usercall f                    @<X0>(
                void *value                             @<X0>,
                Swift::String *target                   @<X1>,
                __int64 name_structfield1               @<X2>,
                __int64 name_structfield2               @<X3>,
                __int64 indent                          @<X4>,
                __int64 maxDepth                        @<X5>,
                __int64 maxItems                        @<X6>,
                __int64 T                               @<X7>,
                void * return_buf                       @<X8>,
                __int64 TargetStream_metadata           @<^0.8>,
                __int64 TargetStream_witnessTable       @<^8.8>);
            """
        )
        if (0): f.options |= Appcall.APPCALL_MANUAL # DEBUG
        f(
            buffer,                                 # X0
            str_sw,                                 # X1
            0,                                      # X2
            0,                                      # X3
            0,                                      # X4
            0x7FFFFFFFFFFFFFFF,                     # X5
            0x7FFFFFFFFFFFFFFF,                     # X6
            typ,                                    # X7
            return_buf,                             # X8
            mfstype("_$sSS"),                       # ^0.8
            mfdlsym("_$sSSs16TextOutputStreamsWP"), # ^8.8
        )
        
        # Validate return value
        if (0): # This assert failed on a KeyboardSettings.ShortcutBehavior instance for some reason (But the resulting description string still looked correct) [May 31 2025]
            assert mfmem[return_buf, f'uint8_t[{mfssize(typ)}];'] == mfmem[buffer, f'uint8_t[{mfssize(typ)}];'], "Dump returns its input value. (Why does it even do that?)"
        
        # Free return buffer
        Appcall.proto(mfdlsym("_free"), "void free(void *);")(return_buf)
        
        # Release
        if mfisobj(mfderef(buffer)): mfsend(mfderef(buffer), "release", proto="id f(void*, void*);") # dump increments the retain count (why?), so we balance that [May 2025]
          
    else: assert False
    
    # Convert result to python string
    str_ns = mfsstr_tons(str_sw);
    str_py = mfdesc(str_ns)
    
    # Return
    return str_py

def mfsmang(typ, _depth=0):
    
    """
    Inverse of `xcrun swift-demangle`/`mfsdemang()`
        Purpose:
            - Documentation/exploration of the type mangling format
            - Quick/easy way to look up manglings for basic types
        Caution: 
            - This is very incomplete. Probably don't make other functions depend on this. 
            - This is only for types, not other mangled symbols.
        Example:
            - xcrun swift-demangle '_$sSDySSypG'      -> [Swift.String : Any]
            - mfsmang('[Swift.String : Any]')         -> _$sSDySSypG
        Also see: https://github.com/swiftlang/swift/blob/main/docs/ABI/Mangling.rst
        Note: There's Remangle.cpp in the Swift source code.
    """
    
    typ = typ.replace(" ", "")
    map = {
        r"Any"                              : "yp",
        r"Swift\.String"                    : "SS",
        r"Swift\.Bool"                      : "Sb",
        r"Swift\.Float64"                   : "Sd",
        r"Swift\.Float32"                   : "Sf",
        r"Swift\.Set"                       : "Sh",
        r"Swift\.Int"                       : "Si",
        r"Swift\.Dictionary"                : "SD",
        r"Swift\.Array"                     : "Sa",
        r"Swift\.AnyObject"                 : "yXl",
        r"Swift\.Equatable"                 : "SQ_p",
        r"Swift\.Hashable"                  : "SH_p",
        r"Swift\.TextOutputStream"          : "s16TextOutputStream_p",
        r"Swift\.KeyPath"                   : "s7KeyPathC",
        r"Swift\.AnyKeyPath"                : "s10AnyKeyPathC",
        r"Swift\.PartialKeyPath"            : "s14PartialKeyPathC",
        r"Swift\.WritableKeyPath"           : "s15WritableKeyPathC",
        r"Swift\.ReferenceWritableKeyPath"  : "s24ReferenceWritableKeyPathC",
        r"(.*?)<(.*?),(.*?),(.*?)>"         : "$0y$1$2$3G",      # Generic 3 (Order of these dict entries matters I think)
        r"(.*?)<(.*?),(.*?)>"               : "$0y$1$2G",        # Generic 2
        r"(.*?)<(.*?)>"                     : "$0y$1G",          # Generic 1
        r"\[(.*?):(.*?)\]"                  : "SDy$0$1G",        # Swift.Dictionary
        r"\[(.*?)\]"                        : "Say$0G",          # Swift.Array
        r"(.*?)\?"                          : "$0Sg",            # Optional?
        # ... Fill in types here as you need them.
    }
    
    result = None
    
    # Parse using map
    for k in map.keys():
        match = re.fullmatch(k, typ, flags=0)
        if not match: continue
        result = map[k]
        for i, g in enumerate(match.groups()):
            result = result.replace(f"${i}", mfsmang(g, _depth=_depth+1))   # Recurse
        break
    
    if result is None:
        # Parse custom types
        #   Examples:
        #       SwiftUI.WindowGroup                                             -> 7SwiftUI11WindowGroupV
        #       swift_ida_playground_apr_2025.ContentView                       -> 29swift_ida_playground_apr_202511ContentViewV
        #       SwiftUI.WindowGroup<swift_ida_playground_apr_2025.ContentView>  -> 7SwiftUI11WindowGroupVy29swift_ida_playground_apr_202511ContentViewVG
        segments = typ.split(".")
        if len(segments) > 1 and segments[0] != "Swift": # The correct mangling for Swift.String is not `5Swift6StringV` but `SS`
            result = ""
            for seg in segments:
                result += f"{len(seg)}{seg}"
            result += "V"   # This is wrong. I think the V is 'nominal struct type' in Mangling.rst – but this info seems not represented in the demangled names. If that's true, the demangled names are a lossy encoding.
        
    assert result is not None, f"Couldn't mangle swift type '{typ}'"
    
    if _depth == 0:
        result = "_$s" + result
    

    return result

# --- MARK: Unused

def _mfsregister_types():
    """
    Based on IDAPython example create_struct_by_parsing.py: https://github.com/HexRaysSA/IDAPython/blob/9.0sp1/examples/types/create_struct_by_parsing.py
      Documents how to programmatically register types inside IDA. – These types will show up in IDA's 'Local Types' view.
    """
    assert False, "Unused"
    
    struct_strs = [
        [
            "MyType",
            """
                struct My Type {
                    void *a;
                    void *b;
                }
            """
        ]
    ]
    for s in struct_strs:
        tif = ida_typeinf.tinfo_t(s[1])
        tif.set_named_type(None, s[0]) # This will make it show up in IDA's type browser.

class MFFlag(enum.IntFlag):
    
    """
    MFFlag
        Higher-level interface for bitflags. 
            [Update: [May 20 2025] Do not use this. The abstraction is not worth it and only obscures things. This was supposed to be a lighter abstraction for Appcall options than mfcall, but it's even worse. Just use Appcall directly.]
        Example-usage:
            class MFAppcallOpts(MFFlag):
                debug   = Appcall.APPCALL_DEBEV
                manual  = Appcall.APPCALL_MANUAL
                timeout = Appcall.APPCALL_TIMEOUT
            Appcall.set_appcall_options(MFAppcallOpts.make(manual=True, debug=False))
            MFAppcallOpts(Appcall.get_appcall_options()).to_dict()
    """
    @classmethod
    def make(cls, val=None, **kwargs): # Overriding __new__ or __init__ gave crypting errors, so we're defining 'make' instead
        if   kwargs:                return cls.from_dict(kwargs)
        elif isinstance(val, dict): return cls.from_dict(val)
        elif isinstance(val, int):  return cls.from_int(val)
        elif val is None:           return cls.from_int(0)
        else:                       assert False
    
    @classmethod
    def from_int(cls, x):   return cls(x)
    def to_int(self):       return self.value
    
    @classmethod
    def from_dict(cls, x):
        i = 0
        for (k, v) in cls.__members__.items():
            i |= v if (k in x and x[k]) else 0
        i |= x.get('__other_bits', 0)
        return cls(i)
    def to_dict(self):
        other_bits = self.value
        result = {}
        for (k,v) in type(self).__members__.items():
            result[k] = bool(self.value & v)
            other_bits &= ~int(v)
        if other_bits: result['__other_bits'] = other_bits
        return result

class _mfcall(ida_idd.Appcall_callable__):
    
    """
    Update: [May 19 2025] Don't use mfcall. This is way too much code for little benefit. Abstraction is not worth it. Just use Appcall directly instead.
        Examples of directly using Appcall directly for the stuff that mfcall was supposed to simplify:
            Global Appcall settings:
                Set: Appcall.set_appcall_options(idaapi.APPCALL_MANUAL | idaapi.APPCALL_DEBEV | (idaapi.APPCALL_TIMEOUT|123<<16))    -> (Timeout of 123 ms)
                Get: Appcall.get_appcall_options()
            Local Appcall settings:
                Get: Appcall[mfdlsym('_printf')].options
                Set:
                    f = Appcall[mfdlsym('_printf')]
                    f.timeout = 100; f.options |= 0         # About `options|=0`: It is necessary to activate the timeout in IDA 9.1.250226 I think (They should fix that) 
                    f.options = idaapi.APPCALL_MANUAL
                    f("Hello %s", "World")
                
    [May 2025] Wrapper around Appcall
        Main reason I made this: Allow using APPCALL_MANUAL and other options from a one-liner
        Examples:
            1. function signature: 0
                Code: mfcall("_NSLog", 0)(mfstr("Hullo %s"), "Wurld");
                Explanation: Passing 0 means 'Use the known function signature from the IDA Database'
            2. debug=True
                Code: print(mferrdesc(mfcatch(lambda: mfcall('_IDAAppcallTest_inoutint', "void f(int *x);", debug=True)(123456))[1]))
                Explanation: We call the function with the invalid pointer 123456, causing an exception. We catch the exception and print its description. Due to debug=True, the errdesc contains detailed information, including the ea of exactly where the issue occured.
            3. manual=True
                Code: 
                    mfcall("_printf", "void f(const char *fmt, ...);", manual=True)("Hello %s", "World");
                    <Step through and debug printf>               
                    mfcall.clean() 
                Explanation: We set manual=True, letting us step through the Appcall. Afterwards, we need to call mfcall.clean().
            4. global options
                Code: 
                    mfcall.setgopts(debug=False, manual=True, timeout=123)  // Set
                    mfcall.setgopts()                                       // Reset
                    mfcall.gopts()                                          // Inspect
                Explanation:
                    Set options globally for all subsequent Appcalls
                    
        Notes:
            timeout is in milliseconds
        Discussion: 
            [May 2025] Too much code for little purpose. Should probably delete this.
    """
    
    # Init
    def __init__(self, name_or_ea, proto_or_tinfo, parse_decl_flags=None, debug=False, manual=False, timeout=0) -> None:
        
        assert False, "Just use Appcall directly instead."
        
        ea  = Appcall._Appcall____name_or_ea(name_or_ea)
        if proto_or_tinfo:
            # Resolve name using mfdlsym    (Cause Appcall's name resolution is spotty (and often leads to confusing issues) (Seems to use idaapi.get_name_ea_simple()) [May 20 2025])
            if isinstance(name_or_ea, str):
                name_or_ea = mfdlsym(name_or_ea)
            # Replicate Appcall.proto functionality
            tif = Appcall._Appcall____typedecl_or_tinfo(proto_or_tinfo, parse_decl_flags)
            super().__init__(ea, tif)
        else:
            # Use the function signature from the database
            super().__init__(ea)
        
        # Set options and timeout on self
        gopts = _mfcall.gopts() # Use global options as base
        self.setopts(debug=(debug or gopts.debug), manual=(manual or gopts.manual), timeout=(timeout or gopts.timeout))
        
    # Cleanup
    @staticmethod
    def cleanup():
        # Use this after a 'manual' appcall to pop it off the context stack (Not sure what the right terminology is. See https://www.youtube.com/watch?v=UQoSyWOUExU)
        Appcall.cleanup_appcall()
        
    # Convert between Appcall flags and `Opts` convenience object
    #   ... Is this really worth all this code?
    
    @dataclass
    class Opts:
        debug: bool = False
        manual: bool = False
        timeout: int = 0
    
    @staticmethod
    def _flags_to_opts(flags):
        opts = _mfcall.Opts()
        opts.debug   =                  bool(flags & Appcall.APPCALL_DEBEV)
        opts.manual  =                  bool(flags & Appcall.APPCALL_MANUAL)
        opts.timeout = flags >> 16 if   bool(flags & Appcall.APPCALL_TIMEOUT) else 0
        return opts
    
    @staticmethod
    def _opts_to_flags(opts):
        flags = 0
        flags |= Appcall.APPCALL_DEBEV                          if opts.debug           else 0
        flags |= Appcall.APPCALL_MANUAL                         if opts.manual          else 0
        flags |= Appcall.APPCALL_TIMEOUT | (opts.timeout << 16) if bool(opts.timeout)   else 0
        return flags
    
    # Get/set local opts
    def opts(self): return _mfcall._flags_to_opts(self.options)
    def setopts(self, **kwargs):
        opts = _mfcall.Opts(**kwargs)
        self.options = _mfcall._opts_to_flags(opts)
        if opts.timeout:
            self.timeout = opts.timeout
            self.options |= 0 # Need this to force update of options I think [May 2025]
    
    # Get/set global opts
    @staticmethod
    def gopts():              return _mfcall._flags_to_opts(Appcall.get_appcall_options())
    @staticmethod
    def setgopts(**kwargs):   Appcall.set_appcall_options(_mfcall._opts_to_flags(_mfcall.Opts(**kwargs)))

mfcall = _mfcall
